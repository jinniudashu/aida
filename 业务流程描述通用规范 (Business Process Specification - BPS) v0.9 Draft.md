
#### 前言

本规范（BPS）是基于 **”状态机世界模型“** 定义 **“业务语义空间”** 的 **“元模型”或“语法规则”**，旨在提供一套通用的、结构化的“语法”，用以描述、设计和执行任何领域的业务蓝图。它本质上定义了一台**业务虚拟机（Business Virtual Machine）** 的规范。任何遵循该规范描述的业务蓝图，实质上都是为这台虚拟机编写的程序。其核心目标是实现 **“业务流程即代码 (Business Process as Code)”**，使得业务蓝图本身即可被运行时引擎理解和执行，并能由AI Agent进行生成、部署、运营维护和操作使用。

为指导用户系统性地构建符合本规范的业务描述，官方推荐采用**SBMP:「标准业务建模过程 (Standard Business Modeling Process)」** 中定义的标准过程。该文档提供了从业务调研到模型建立的完整操作指南。

##### 背景理念

本规范基于这样一个基本理念——**世界是个状态机**。即任何现实世界的组织活动均可被视为一个在运行的计算系统，该系统执行特定的过程，将某个标的物的状态从A改变为B，该过程是组合、调度特定资源（可映射为数据和计算节点）与活动（计算任务）的过程。这些过程可视为一套规则（业务程序）在企业组织这一分布式人脑计算系统（计算节点网络 + 业务流程执行引擎 + 状态管理工具）上的运行的结果。

基于该背景理念，我们将业务过程抽象为可由计算系统执行的“进程”，并借鉴了操作系统的核心概念（如进程管理、资源调度、事件驱动）构建了一个通用的业务流程执行引擎/虚拟机，用来“运行”符合本规范的业务描述/业务程序。

##### 规范目的与前提

本规范的目的是用于指导业务设计者（人或AI Agent）使用配套的设计器来描述其业务蓝图。它是一套完整工具链的“使用指南”，其有效应用需基于以下前提：

1. 存在一个与本规范配套的**设计器**，用于辅助创建和管理符合本规范的业务描述。
2. 存在一个与本规范配套的**运行时环境（执行引擎/虚拟机）**，负责解释和执行这些 **业务描述/业务应用程序** 。

遵循本规范意味着该业务描述所包含的业务语义要素是**完备的**。这种“完备”使得该描述可以用设计器中包含的代码生成器生成特定编程语言的业务状态管理系统源代码，并最终可被特定的业务流程执行引擎管理和驱动。

**注意**: 本规范仅用于指导业务设计，与实现系统的语言和框架工具无关。

---

### 第一部分：元模型核心结构 (Core Meta-Model Structure)

BPS由以下六个核心组件构成，它们共同定义了一个完整的业务蓝图：

1. **`Entity` (实体)**: 业务世界中的基础对象及其构成关系，是静态世界的基石。**`Entity` 是 `Entities` 的组合**。
2. **`Service` (服务)**: 业务活动或任务的类型定义，定义了“做什么”。它可以是原子的，也可以是由`Rules`编排其他`Service`构成的复合体。**其名称是一种 `Entity`**。
3. **`Rule` (规则)**: 驱动流程运转的业务逻辑，定义了“在什么条件下做什么”。它将`Event`（由`Entity`表达式定义）映射到`Instruction`。**其名称是一种 `Entity`**。
4. **`Role` (角色)**: 执行业务活动的计算节点类型的抽象，定义了“谁来做”。**其名称本身也是一种 `Entity`**。
5. **`Instruction` (指令)**: 运行时引擎对外暴露的、不可再分的原子操作接口，是业务编排的原子动词。**其名称是系统保留的 `Entity`**。
6. **`Process` (进程)**: Service的运行时实例，是业务系统的基础单位本体，是业务状态迁移的载体，由运行时环境负责实现和管理。

##### 组件关系总结

前五大核心概念结构化定义了 Process ：Entity 构成了 Process 上下文堆栈内容，Service 规定了 Process 的任务类型，Rule 规定了 Process 产生的条件，Role 规定了执行 Process 的计算节点类型，Instruction 规定了运行时系统处理 Process 映射的方式。

将系统初始状态转变为目标状态，需要运行时环境根据`Rule`推动一系列的`Process`。每个`Process`是一个特定`Service`的运行实例，由特定的`Role`实例（计算节点）来执行运算。`Entity`、`Role`、`Service`和`Rule`由用户根据业务语义进行定义，运行时环境则根据用户的定义自动进行计算资源的调度，从而推动整个业务系统由初始状态向目标状态递进。

---

### 第二部分：`Entity` (实体)

“有名万物之始”。在BPS中，一个名字即定义一个业务实体。实体可以是任何词汇，只要不与已有名字重复。它是所有业务概念的载体。

业务实体具有**语义属性**和**实现属性**。

#### 语义属性 (Semantic Properties)

- **名称**: 一个具有明确语义指向的词汇，是实体的唯一标识。
- **描述**: 对实体名称的自然语言解释。
- **业务类型**: 指出该实体在范畴上可归入的另一个实体。这是一种“is-a”关系，实现时可能映射为“类型-实例”关系，也可能映射为“类型继承”关系。例如，“医生”的业务类型是“员工”。
- **业务隶属**: 指出该实体在结构上隶属于另一个实体。这是一种“part-of”关系，实现时映射为实体之间的一对多或多对多关系。例如，“健康记录”隶属于“客户”，“姓名字段”隶属于“客户档案”。

#### 实现属性 (Implementation Properties)

- **子类定义**: 一个由明确的业务实体约束关系构成的表达式，用于从一个更宽泛的业务类型中精确定义出当前实体。例如，名为“领用人”的实体，其子类定义可以是 `role__label__in=['医生','护士','客服']`。
- **实现类型**: 该实体在系统实现时的对象类型，该对象类型与具体编程语言无关。
	- 类型列表：['FIELD', 'LITERAL', 'ENUM_OBJECT', 'DATA_TABLE', 'SYSTEM_TABLE', 'VIEW', 'LOG', 'FILE', 'UI_ITEM']
	- [('Field', '字段'), ('Literal', '字面量'), ('Enum', '枚举对象'), ('Model', '数据表'), ('KernelModel', '系统表'), ('Log', '日志'), ('File', '文件'), ('View', '视图'), ('UIComponent', 'UI组件'), ('Program', '程序')]
	- ('KernelModel', '系统表') 由运行时环境实现的系统保留业务实体：['Service', 'Role', 'Rule', 'Event', 'Process', 'Operator', 'Resource']
- **依赖顺序**: 一个整数，用于表示在系统实现多个实体时之间的先后依赖关系，数字越小越优先。
- **初始值**: 该实体的初始值。

#### 核心提示

- **万物皆实体**: 在本规范中，`服务`、`角色`、`规则`、`事件`等所有核心概念的**名称**本身，都是被管理并预先实现的保留业务实体。
- **实体皆可组合**: 实体可以由多个其他实体组成，实体之间通过隶属关系构成复杂的结构。例如，“某事件”可由一组业务实体的约束关系来定义。

#### 元业务实体 (Meta-Entities)

规范提供一组最基础的、系统保留的元业务实体，它们内置于设计器和运行时环境中，是用户定义更复杂实体的基础。

- **保留业务实体**: `服务`, `角色`, `规则`, `事件`, `进程`, `人员`, `资源`
- 保留业务实体即是保留业务类型
- **基础类型**: `时间`, `数字`, `文本`, `布尔`, `列表`, `字典`

---

### 第三部分：`Service` (服务)

`Service`是对一项业务任务的**类型定义**。可以将其类比为程序或函数。`Service`的名字是一个业务实体。

- **原子性与复合性**: `Service`可以是原子化的，也可以是由`Rule`组织起来的其他`Service`嵌套（含递归）组合而成的复合服务。该属性由设计器和运行时保留实现： `composition_type: 'ATOMIC' | 'COMPOSITE'`。当类型为 `'COMPOSITE'` 时，其定义必须关联一个或多个 `Rule` 的名称。

- **输入与输出**: 服务可以有输入参数（入参）和输出参数（出参）。入参和出参本身也都是业务实体，也可以是另一个`Service`。

---

### 第四部分：`Rule` (规则)

`Rule`是驱动业务流程流转的事件与逻辑，它定义了“在什么条件下，执行什么指令”。其内容可视为**业务程序体**。`Rule`的名称是一个业务实体。

- **核心结构**: `Event (事件表达式) -> Instruction (系统指令)` 的映射关系集合。

- **作用域**: `Rule`可以隶属于全局，对整个系统生效；也可以隶属于一个特定的`Service`，仅在该服务的上下文中生效。

- **事件定义 (`Event`)**: `Event`是规则的触发器，由`Entities`的布尔表达式组合来定义。
    - **`expression`**: 事件的具体内容。可以是布尔表达式或自然语言描述。
    - **`evaluation_mode`**: 定义了事件的评估模式，用以指导运行时引擎的行为。
        - `DETERMINISTIC` (确定性): `expression`是一个严格的布尔表达式，由运行时引擎自动评估。
        - `NON_DETERMINISTIC` (非确定性): `expression`是一段自然语言描述，运行时引擎需将此事件路由给具备判断能力的`Operator`（人或AI）进行评估，并等待其返回结果。`Operator`在做出判断后，要么返回一个布尔型的判断结果，明示此事件是否发生，要么返回一个保留异常 `无法判断`，以及可选的备注信息。
    - `Event`可以是进程状态事件、上下文数据事件，或是它们的组合。
    - **系统保留异常事件**: `process.on_exception == true`。

- **错误处理**: 通过为系统保留的“异常”事件编写`Rule`，将错误处理逻辑无缝融入业务流程设计中。


---

### 第五部分：`Role` (角色)

Role 部分定义的是业务流程中需要的角色类型 (Role Types)，是对计算节点类型的抽象。运行时环境负责管理这些角色类型的具体实例（例如，“医生”类型下的“张三医生”实例），并将进程任务调度给他/它们。

- **角色类型**:
    - `USER_DEFINED`: 用户定义的业务角色（如医生、客服）。
    - `SYSTEM_RESERVED`: 系统内置角色（如`System`自身、`Timer`定时器），用于执行自动化任务。

- **角色能力 Role capability**: [Services]
    
- **角色实例**（计算节点）: `Role`的实例 `Operator` 是最终被调度执行进程任务的计算单元，可以是**某个系统用户、某个AI Agent、自动化系统工具**等任何具备计算能力（接受特定输入，给出特定输出）的对象。`Operator` 由运行时引擎管理。

所有的 Role 本身也是业务实体。

---

### 第六部分：`Instructions` (指令集)

`Instruction`是运行时引擎原生支持的原子命令集，是运行时引擎对外暴露的系统操作的接口。是`Rule`的动作部分，供业务设计者在`Rule`中编排业务程序。

#### 流程控制指令

- `启动服务` start_service(Service)
- `并行启动` start_parallel(n, Service)
- `迭代启动` start_iteration(n, Service)
- `调用子服务` call_sub(Service)
- `调用返回` return_from_call: Entity instance

#### 异常处理指令

- `重试任务` (retry_process)
- `终止任务` (terminate_process)
- `上报任务` (escalate_process)
- `回退任务` (rollback_process)

---

### 第七部分：`Process` (进程)

Process 是运行时引擎执行业务程序时产生的动态信息实体，是业务状态迁移的载体，是业务系统的基本单元本体。

为了让本规范可执行，运行时引擎需要实现和管理以下实体：

- **`Process`**: 一个`Service`的运行时实例。它拥有一个生命周期状态机（如 `NEW`, `READY`, `RUNNING`, `COMPLETED`, `FAILED`）。
- **`ProcessContext`**: 每个`Process`的执行上下文，有运行时引擎负责维护。它是一个堆栈式的数据容器，保存了当前进程关联的`Service`实体实例、输入输出参数、以及临时变量。所有的`Event`表达式都在此上下文中进行求值。

---

### 第八部分：设计器 & 运行时环境 (Designer & Runtime)

#### 设计器 (Designer)

`Designer`的功能是让用户/Agent能够定义一个业务系统的“词汇”和“语法”：

- **业务实体定义 (DataItem)**：这是最核心的元建模功能。用户可以定义任意业务实体及其关系。
- **服务与流程定义 (Service & Rule)**：用户可以定义原子性服务和由规则串联的组合性服务。
- Designer负责业务设计内容的持久化管理，并将其转译加载到运行时环境。

#### 运行时环境 (Runtime Environment)

运行时环境是执行本规范所描述业务蓝图的引擎。其核心职责包括：

- **事件驱动**: 通过监听业务状态的变化来触发业务事件。
- **进程管理**: 根据业务规则创建和管理服务进程。
- **上下文管理**: 负责为进程维护上下文堆栈。
- **计算资源调度**: 将进程调度给恰当的计算节点实例来执行。
- **状态持久化**: 负责持久化系统全局状态和进程上下文状态。

---

### 第九部分：总结 (Conclusion)

《业务流程描述通用规范》以“世界是个状态机”为第一性原理，将纷繁复杂的商业活动描述，抽象为由`实体`、`服务`、`规则`、`角色`和`指令集`这五个核心元模型所定义的、可被结构化调度的`进程`（Process）。

本规范的核心贡献在于其**彻底的“实体化”和“规则驱动”思想**。通过将包括服务、角色、规则在内的所有业务概念的“名称”都统一为可管理的`实体`，构建了一个自洽、可扩展的元语义业务词汇空间。同时，通过将所有流程的推进逻辑都归结为`事件 -> 指令`的`规则`，它将业务流程的实现从硬编码中解放出来，使其变得透明、灵活且易于演进。

最终，BPS 不仅定义了“如何描述业务”，更指明了“如何思考业务”，它提供了一个通用且稳定的元语义框架，为构建一个业务操作系统的内核提供了核心概念规范。

